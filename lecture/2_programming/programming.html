<!DOCTYPE html>
<html lang="" xml:lang="">
  <head>
    <title>Data Analysis using R</title>
    <meta charset="utf-8" />
    <meta name="author" content="Sven Werenbeck-Ueding" />
    <script src="programming_files/header-attrs-2.23.3/header-attrs.js"></script>
    <link href="programming_files/remark-css-0.0.1/default.css" rel="stylesheet" />
    <link href="programming_files/remark-css-0.0.1/default-fonts.css" rel="stylesheet" />
    <link href="programming_files/panelset-0.2.6/panelset.css" rel="stylesheet" />
    <script src="programming_files/panelset-0.2.6/panelset.js"></script>
    <link href="programming_files/tile-view-0.2.6/tile-view.css" rel="stylesheet" />
    <script src="programming_files/tile-view-0.2.6/tile-view.js"></script>
    <script src="programming_files/htmlwidgets-1.5.4/htmlwidgets.js"></script>
    <script src="programming_files/viz-1.8.2/viz.js"></script>
    <link href="programming_files/DiagrammeR-styles-0.2/styles.css" rel="stylesheet" />
    <script src="programming_files/grViz-binding-1.0.9/grViz.js"></script>
    <link rel="stylesheet" href="style.css" type="text/css" />
  </head>
  <body>
    <textarea id="source">
class: center, middle, inverse, title-slide

.title[
# Data Analysis using R
]
.subtitle[
## Programming
]
.author[
### Sven Werenbeck-Ueding
]
.date[
### 22.09.2023
]

---


&lt;!-- Setup --&gt;







<div id="htmlwidget-8d4fc50414c311363fb0" style="width:100%;height:504px;" class="grViz html-widget"></div>
<script type="application/json" data-for="htmlwidget-8d4fc50414c311363fb0">{"x":{"diagram":"\n  digraph {\n    fontname=\"Helvetica,Arial,sans-serif\"\n\tnode [fontname=\"Helvetica,Arial,sans-serif\"]\n\tedge [fontname=\"Helvetica,Arial,sans-serif\"]\n    \n    rankdir=LR\n    \n    subgraph cluster_0 {\n        style = rounded\n        color = black\n    \n        {\n            node [style = rounded, shape = box]\n            Import -> Tidy\n        }\n    \n        subgraph cluster_1 {\n            style = rounded\n            color = black\n            \n            node [style = rounded, shape = box]\n            Transform Visualize Model\n            \n            edge []\n            Transform -> Visualize\n            Visualize -> Model\n            Model -> Transform\n            \n            label = \"Exploration\"\n            labeljust = \"l\"\n            labelloc = \"b\"\n        }\n    \n        {\n            node [style = rounded, shape = box]\n            Communicate\n        }\n    \n        Tidy -> Transform\n        Model -> Communicate [ltail = cluster_1]\n        \n        label = \"Programming\"\n        labeljust = \"l\"\n        labelloc = \"b\"\n    }\n  }\n  ","config":{"engine":"dot","options":null}},"evals":[],"jsHooks":[]}</script>

.right[*Source:* &lt;a name=cite-r4ds&gt;&lt;/a&gt;[Wickham and Grolemund (2016)](https://r4ds.had.co.nz/)]

---

class: middle

# Functional Programming

---

## Functional Languages

- Programming languages with **first-class functions** are called functional languages
  
- First-class functions behave like other data structures, i. e. they can be 

  - Assigned to variables
  - Passed on to other functions as arguments
  - Created inside functions

- Functions are often required to be **pure**, i. e. they satisfy:
  
  - The output is determined by its input so that it always returns the same output given the same input
  - There are no side-effects to a function so that it does not change the global environment, disk or displays output on the screen
  
--

.pull-left.short-width[
.big-emoji[⚠️]
]

.pull-right.long-width[
- Not all functions in R are pure (e. g. `rnorm()` generates random numbers from a normal distribution), but they are first-class functions

- Yet, at its core, R is a functional programming language

- Functional style can be adopted by separating pure and non-pure functions
]

---

class: middle

## Functional Style

&gt; It’s hard to describe exactly what a [functional programming] style is, but generally [...] it means **decomposing a big problem into smaller pieces**, then solving each piece with a function or combination of functions.
&gt;
&gt; When using a functional style, you strive to **decompose components of the problem into isolated functions** that operate independently. Each function taken by itself is simple and straightforward to understand; complexity is handled by composing functions in various ways.
&gt;
&gt; .right[&lt;a name=cite-advancedr&gt;&lt;/a&gt;[Wickham (2019)](http://adv-r.had.co.nz/)]

---

layout: false
class: middle

# Functions in R

---

layout: true

## Why use functions in R?

---

.pull-left[
- The code on the right creates a data frame with 50 observations and three variables (`x`, `y`, `z`) drawn from normal distributions `\(N(\mu,\sigma)\)` with `\(\mu=5\)` and `\(\sqrt\sigma=10\)`

- Each variable is standardized: `\(\frac{x-\bar{x}}{\sqrt{\sigma_x}}\)`

- This approach is bad practice &amp;rarr; copy-pasting code is **prone to errors** and **hard to maintain**

- Does not improve readability and comprehensiveness of the code
]
.pull-right[

```r
# Create a data frame with 50 observations
# and 3 normal distributed variables with 
# mean 5 and standard deviation 10
df &lt;- data.frame(x = rnorm(50, 5, 10),
                 y = rnorm(50, 5, 10),
                 z = rnorm(50, 5, 10))
```


```r
# Standardize each variable
df$x &lt;- (df$x - mean(df$x)) / sd(df$x)
df$y &lt;- (df$y - mean(df$y)) / sd(df$y)
df$z &lt;- (df$z - mean(df$z)) / sd(df$z)
```

]

--

.pull-left.short-width[
.big-emoji[❌]
]

.pull-right.lo-wi[
#### Do not try at home!
]

---

.pull-left[
- Instead, we can write a function with a proper name that **takes a numeric vector** as input and **returns the standardized vector**

- The function can then be applied to each column of the data frame that we have created in advance

- This function is more **readable** and **comprehensive**

- **Maintaining the code becomes easier** because altering the standardization requires only adjusting the function `standardize()`

- Writing a function should be considered when the same code is repeated several times

- Because R use first-class-functions, it is inherently made for using functional programming
]
.pull-right[

```r
standardize &lt;- function(x) {
  mean_x &lt;- mean(x)
  
  sd_x &lt;- sd(x)
  
  (x - mean_x) / sd_x
}
```



```r
df$x &lt;- standardize(df$x)
```

]

---

layout: false

## Function Components

.pull-left[
- There are three key components to functions:
  
  1. The **name** of a function is assigned using the `&lt;-` operator
  2. The function **arguments** are provided in the parentheses of `function()`, separated by commas
  3. The **body** defines what is executed on the arguments and is placed the in curly brackets `{...}` after `function()`
  
- Binding a function to a name is not required &amp;rarr; **anonymous function**

- The return value can be defined using `return()` or simply the last printed object (as in the `standardize()` function)
]

.pull-right[

```r
&lt;NAME&gt; &lt;- function(&lt;ARGUMENTS&gt;) {
  &lt;BODY&gt;
}
```

]

---

layout: true

## Function Arguments

---

.pull-left[
- Function arguments can generally be categorized in
  
  1. the **data** to compute the body on
  2. the **details** of the computation

- Example: `log()` takes `x` as the data argument and the details of the computation are defined by the argument `base`

- Default arguments can be specified in `function()`, e. g. the default value for `base` in `log()` is `exp(1)`
]
.pull-right[

```r
log
```

```
## function (x, base = exp(1))  .Primitive("log")
```
]

---

#### Best Practices

- Data arguments are placed before details arguments

- Default values are set to their most common value (e. g. 0.95 for confidence level)

- Empty spaces around `&lt;-` and `=`

- Match names of arguments in existing R functions for consistency:

  - `x`, `y`, `z`: vectors
  - `w`: weights
  - `df`: data frame
  - `i`, `j`: numeric indices (such as rows and columns)
  - `n`: number of rows (matrices and data frames) or vector length
  - `p`: number of columns (for matrices and data frames)

---

layout: false

## Checking Argument Values

.pull-left[
- It is good practice to check arguments for their validity to avoid the function body to through errors

- Can use `if` statements to check whether values given for arguments satisfy conditions

- If an input does not satisfy these conditions, we can `stop()` the execution of the function early on

- We can pass a string to `stop()` to notify the user of what went wrong

- Example: `x` in our `standardize()` function has to be of type numeric
]
.pull-right[
.panelset[
.panel[.panel-name[Function]

```r
standardize &lt;- function(x) {
  if(!is.numeric(x))
    stop("x has to be numeric")
  
  x_mean &lt;- mean(x)
  
  x_sd &lt;- sd(x)
  
  (x - x_mean) / x_sd
}
```
]
.panel[.panel-name[Error]
.scroll-box-14[

```r
not_numeric &lt;- c("This",
                 "is",
                 "not", 
                 "numeric")

standardize(not_numeric)
```

```
## Error in standardize(not_numeric): x has to be numeric
```
]
]
]

]

---

layout: true

## Lexical Scoping

---
.pull-left[
&gt; R [...] looks up the values of names based on how a function is defined, not how it is called.
&gt;
&gt; “Lexical” here is not the English adjective that means relating to words or a vocabulary. It’s a technical CS term that tells us that the scoping rules use a parse-time, rather than a run-time structure.
&gt;
&gt; .right[[Wickham (2019)](http://adv-r.had.co.nz/)]

]

--

.pull-right[
Lexical scoping means that R follows these rules:

1. **Name masking**

2. **Functions over variables**

3. **Independent invocation**

4. **Dynamic lookup**
]

---

.panelset[
.panel[.panel-name[Name Masking]
.pull-left[
- Names defined inside a function mask names outside a function

- If R cannot find a name inside a function, it looks for the name outside the function (e. g. in the global environment)
]
.pull-right[

```r
y &lt;- 5

some_function &lt;- function() {
  print(y)
}

some_function()
```

```
## [1] 5
```

]
]
.panel[.panel-name[Functions over Variables]
.pull-left[
- If a function and a variable residing in different environments share the same name, R chooses the function if the name is called

- Two objects should never be named the same, regardless of this behavior!
]
.pull-right[

```r
y_1 &lt;- function(x) x + 5

y_2 &lt;- function() {
  y_1 &lt;- 5
  y_1(y_1)
}

y_2()
```

```
## [1] 10
```

]
]
.panel[.panel-name[Independent Invocation]
.pull-left[
- Each function call is executed in a new environment

- Names defined during function call are not present, when executing the function call again

- You may have noticed that running `standardized()` in your environment does not create variables `x_mean` and `x_sd`
]
.pull-right[

```r
some_function &lt;- function(x) {
  x + 5
}

some_function(5)
```

```
## [1] 10
```

```r
some_function(5)
```

```
## [1] 10
```
]
]
.panel[.panel-name[Dynamic Lookup]
.pull-left[
- R looks for names only when the function is executed, not when it is created

- Reassigning variables that are defined outside the function but called during the function execution, may change the function output
]
.pull-right[

```r
some_function &lt;- function() {
  x + 5
}

x &lt;- 10

some_function()
```

```
## [1] 15
```

```r
x &lt;- 15

some_function()
```

```
## [1] 20
```
]
]
]

---

layout: false

## Lazy Evaluation

.pull-left[
- Arguments are only evaluated when they are accessed by R (**lazy evaluation**)

- If an argument of a function is not called inside the function, it is not evaluated by R, potentially saving resources when the evaluation would be computationally expensive

- Allows for defining default arguments in terms of other arguments
]
.pull-right[

```r
some_function &lt;- function(x = 5,
                          y = 1,
                          z = x + y) {
  z
}

some_function()
```

```
## [1] 6
```

]

---

## Ellipsis

.pull-left[
- An **ellipsis** (`...`) is a reserved special argument that captures all arguments not otherwise matched by the function specification

- Useful when writing functions that primarily wrap other functions

- Example: Our `standardize()` wraps around `mean()` and `sd()`

  - If we call `standardize()` on a vector with missing values, `mean()` and `sd()` would throw errors
  - Since both `mean()` and `sd()` take the same argument, we may want to pass these arguments in `standardize()` down to these functions
]
.pull-right[

.panelset[
.panel[.panel-name[Code]

```r
standardize &lt;- function(x, ...) {
  if(!is.numeric(x))
    stop("x has to be numeric")
  
  x_mean &lt;- mean(x, ...)
  
  x_sd &lt;- sd(x, ...)
  
  (x - x_mean) / x_sd
}

# Create a vector with one NA and two
# random values
vec_na &lt;- c(NA, rnorm(2, 5, 10))

standardize(vec_na, na.rm = TRUE)
```
]
.panel[.panel-name[Output]

```
## [1]         NA -0.7071068  0.7071068
```
]
]

]

---

layout: true

## Apply Functions

---

.pull-left[
- Writing functions is most useful when the execution of their body is needed multiple times in your code

- Example: we want to use `standardize()` on each column of `df`

- We could `for` loop through all columns of `df`
]
.pull-right[

```r
# Number of columns in df
df_ncol &lt;- ncols(df)

# Loop through columns and standardize
for(i in 1:df_ncol) {
  df[,i] &lt;- standardize(df[,i])
}
```
]

--

.pull-left.short-width[
.big-emoji[❌]
]

.pull-right.lo-wi[
A better approach is to use `apply()` on `df`!
]

---


```r
?apply
```
.pull-left[
- `apply()` returns a vector, matrix or list of values returned by applying a function to margins of a matrix

- *Very* useful for applying functions over rows or columns of data frames and matrices

- Takes a matrix `X` as an input and applies a function `FUN` over `MARGIN`

- `MARGIN` specifies whether `FUN` should be applied over rows (`=1`), columns (`=2`) or both (`=c(1, 2)`)

- Since `df` can be coerced to a matrix, we can apply `standardize()` over `MARGIN=2` to obtain a matrix with standardized columns
]
.pull-left[
.panelset[
.panel[.panel-name[Code]

```r
apply(X = df, MARGIN = 2, FUN = standardize)
```
]
.panel[.panel-name[Output]
.scroll-box-16[

```
##                  x            y           z
##  [1,] -0.902989749 -1.607382773  0.82239094
##  [2,] -1.591457074  0.981945123  1.68423570
##  [3,]  1.474648381  0.054795541 -0.48325646
##  [4,]  0.507779331 -0.828757940 -0.36732221
##  [5,] -1.506265371  1.387602187  0.83348037
##  [6,] -0.594320923  0.222203343  0.28248840
##  [7,]  1.921568772  0.109069578 -1.34015763
##  [8,] -0.726558873 -0.919285717 -1.01983414
##  [9,] -0.280081758 -0.486610537  0.81519826
## [10,] -0.238417370  0.713416861 -0.62671869
## [11,]  0.999179882 -0.003676887  0.28213644
## [12,] -0.346820328 -0.546517979 -0.32575249
## [13,]  0.205934630 -0.348933478 -0.19555534
## [14,]  0.408510791  0.385013099  0.50282624
## [15,] -0.575518537 -0.093584781  1.06454160
## [16,]  1.161792808 -2.483570167 -0.45728735
## [17,] -0.072101785  1.200701800 -0.07052561
## [18,]  0.053002225  1.429481545  0.31178809
## [19,] -0.855489466  0.446832348  0.17474499
## [20,]  1.610464576  0.082001632 -0.73942526
## [21,]  0.236253828  0.142486495  2.29233616
## [22,]  2.225145034  1.589266863 -0.98451069
## [23,]  0.860356134 -0.218927558 -0.74098579
## [24,] -0.293540767 -1.296241601 -0.53220015
## [25,] -1.265493999  0.158480079 -0.76453990
## [26,] -1.302827003 -0.540144452  0.42568648
## [27,]  0.147158544 -0.873414120 -0.86950900
## [28,] -0.003751267 -1.155982580 -1.36994989
## [29,]  0.568857205 -1.784118368 -0.19764132
## [30,] -0.205605828 -1.212526300 -1.38770610
## [31,]  1.031904167  1.328074171  0.71028196
## [32,]  0.752430000  0.483784905 -1.16465150
## [33,] -1.138130894  0.466145982  0.72298455
## [34,]  1.715703077 -0.807796362 -1.14596663
## [35,]  0.844731948 -0.532760978  1.36417711
## [36,]  0.772630842 -0.613699325 -0.84223887
## [37,]  0.053761674  1.412484548  3.21950153
## [38,] -0.320010794  0.906876796 -1.47047307
## [39,] -0.385341197  0.558483314  0.28642136
## [40,]  1.735753103  1.064398742  0.83538637
## [41,] -0.052595022  1.728171301 -1.47138414
## [42,] -0.582564843 -0.422296368 -0.91851486
## [43,] -0.574227148  0.393101701  0.62718791
## [44,]  0.028329811  0.253905502  0.17153767
## [45,] -2.049485024 -1.632553121  0.03924622
## [46,] -0.983006321  1.825553967  0.54499990
## [47,]  0.559389629 -1.347749212 -0.17749851
## [48,] -1.455980909 -0.152820641  1.15890042
## [49,] -1.246558692  0.624858776  0.85079001
## [50,] -0.326145450 -0.039784954 -0.35966313
```
]
]
]
]
 
---

layout: false

## Variants of Apply

There are several `*apply()` functions, each tailored to specific requirements for input and output types:

- `lapply(X, FUN, ...)`: applies `FUN` over a list

- `sapply(X, FUN, ..., simplify = TRUE, USE.NAMES = TRUE)`: wrapper of `lapply` that returns a vector or matrix

- `vapply(X, FUN, FUN.VALUE, ..., USE.NAMES = TRUE)`: has a pre-specified type of return value given by `FUN.VALUE`

---

layout: false

## Apply Anonymous Functions

Instead of applying our `standardize()` function, we could have defined an anonymous function inside `apply()` with the same result:

.panelset[
.panel[.panel-name[Code]

```r
apply(df, 2, function(x) (x - mean(x)) / sd(x))
```
]
.panel[.panel-name[Output]
.scroll-box-16[

```
##                  x            y           z
##  [1,] -0.902989749 -1.607382773  0.82239094
##  [2,] -1.591457074  0.981945123  1.68423570
##  [3,]  1.474648381  0.054795541 -0.48325646
##  [4,]  0.507779331 -0.828757940 -0.36732221
##  [5,] -1.506265371  1.387602187  0.83348037
##  [6,] -0.594320923  0.222203343  0.28248840
##  [7,]  1.921568772  0.109069578 -1.34015763
##  [8,] -0.726558873 -0.919285717 -1.01983414
##  [9,] -0.280081758 -0.486610537  0.81519826
## [10,] -0.238417370  0.713416861 -0.62671869
## [11,]  0.999179882 -0.003676887  0.28213644
## [12,] -0.346820328 -0.546517979 -0.32575249
## [13,]  0.205934630 -0.348933478 -0.19555534
## [14,]  0.408510791  0.385013099  0.50282624
## [15,] -0.575518537 -0.093584781  1.06454160
## [16,]  1.161792808 -2.483570167 -0.45728735
## [17,] -0.072101785  1.200701800 -0.07052561
## [18,]  0.053002225  1.429481545  0.31178809
## [19,] -0.855489466  0.446832348  0.17474499
## [20,]  1.610464576  0.082001632 -0.73942526
## [21,]  0.236253828  0.142486495  2.29233616
## [22,]  2.225145034  1.589266863 -0.98451069
## [23,]  0.860356134 -0.218927558 -0.74098579
## [24,] -0.293540767 -1.296241601 -0.53220015
## [25,] -1.265493999  0.158480079 -0.76453990
## [26,] -1.302827003 -0.540144452  0.42568648
## [27,]  0.147158544 -0.873414120 -0.86950900
## [28,] -0.003751267 -1.155982580 -1.36994989
## [29,]  0.568857205 -1.784118368 -0.19764132
## [30,] -0.205605828 -1.212526300 -1.38770610
## [31,]  1.031904167  1.328074171  0.71028196
## [32,]  0.752430000  0.483784905 -1.16465150
## [33,] -1.138130894  0.466145982  0.72298455
## [34,]  1.715703077 -0.807796362 -1.14596663
## [35,]  0.844731948 -0.532760978  1.36417711
## [36,]  0.772630842 -0.613699325 -0.84223887
## [37,]  0.053761674  1.412484548  3.21950153
## [38,] -0.320010794  0.906876796 -1.47047307
## [39,] -0.385341197  0.558483314  0.28642136
## [40,]  1.735753103  1.064398742  0.83538637
## [41,] -0.052595022  1.728171301 -1.47138414
## [42,] -0.582564843 -0.422296368 -0.91851486
## [43,] -0.574227148  0.393101701  0.62718791
## [44,]  0.028329811  0.253905502  0.17153767
## [45,] -2.049485024 -1.632553121  0.03924622
## [46,] -0.983006321  1.825553967  0.54499990
## [47,]  0.559389629 -1.347749212 -0.17749851
## [48,] -1.455980909 -0.152820641  1.15890042
## [49,] -1.246558692  0.624858776  0.85079001
## [50,] -0.326145450 -0.039784954 -0.35966313
```
]
]
]

---

layout: false
class: middle

# Composing Functions

---

## Function Composition

.pull-left[
- In `base` R, multiple functions can be composed by:

  1. Saving intermediate results
  2. Nesting functions
  
- Both approaches are rather flawed

- Saving intermediate results requires assigning function output, eventually floating the environment with many irrelevant objects

- Nesting functions may reduce readability and comprehensiveness of your code

- Example: Applying `stanardize()` over columns of `df` returns a matrix. We may want to coerce the resulting matrix back to a data frame using `as.data.frame()`
]
.pull-left[
.panelset[
.panel[.panel-name[Intermediate Results]

```r
df_std &lt;- apply(df, 2, standardize)
df_std &lt;- as.data.frame(df_std)
```

]
.panel[.panel-name[Nested Functions]

```r
as.data.frame(
  apply(
    df,
    2,
    standardize
  )
)
```

]
]
]

---

layout: false
class: middle
background-image: url("https://magrittr.tidyverse.org/logo.png")
background-size: 100px
background-position: 90% 10%

## `magrittr`

&gt; The magrittr package offers a set of operators which make your code more readable by:
&gt;
&gt; - structuring sequences of data operations left-to-right (as opposed to from the inside and out),
&gt;
&gt; - avoiding nested function calls,
&gt;
&gt; - minimizing the need for local variables and function definitions, and
making it easy to add steps anywhere in the sequence of operations.
&gt;
&gt; The operators pipe their left-hand side values forward into expressions that appear on the right-hand side, i.e. one can replace f(x) with x %&gt;% f(), where %&gt;% is the (main) pipe-operator. When coupling several function calls with the pipe-operator, the benefit will become more apparent.
&gt;
&gt; .right[&lt;a name=cite-magrittr&gt;&lt;/a&gt;[Bache and Wickham (2022)](#bib-magrittr)]

---

## What are "packages"?

- Packages are bundles of R code, data and documentation that are often shared via the **Comprehensive R Archive Network** (CRAN)

- R packages are often developed by small teams and made available via CRAN for anyone to download (open source)

- To install and load the `magrittr` package on your system, run the code below

- Content from loaded packages is only available in your current session &amp;rarr; if you close and reopen R, you have to run `library(magrittr)` again but **not** have to re-install it


```r
install.packages("magrittr")
library(magrittr)
```

---

## The Pipe-Operator

.pull-left[
- The pipe operator (`%&gt;%`) is **immensely** useful for writing comprehensive code in functional programming style

- `%&gt;%` does what the name implies: It pipes the value on the left side into an expression or function on the right side

- Pipes can be chained, e. g. `x %&gt;% f_1() %&gt;% ... %&gt;% f_n()`

- Functions are sequentially executed on the output of the previous function

- Keyboard shortcut: `Ctrl + Shift + M`

- Example: Pipe `df` through `apply()` and `as.data.frame()`
]
.pull-right[

```r
df %&gt;% 
  apply(2, standardize) %&gt;% 
  as.data.frame
```

]

---

## Features of the Pipe-Operator

1. Left-hand side (LHS) is piped into the right-hand side (RHS) as the first argument of the function

2. `%&gt;%` can be used *inside* functions as well

3. The LHS can be explicitly called with a dot (`.`) if it is needed at a different argument position of the RHS (not to be confused with the dot in R formulas!)

4. Parentheses can be omitted when the LHS needs only a single argument that is at the first position (not recommended)

---

## ⚠️ Base R's Pipe Operator

.pull-left[
- As of version 4.1.0, base R supports the native pipe operator `|&gt;`

- Version 4.2.0 added a placeholder for the LHS (`_`)

  - Works only if the argument is named

- Apart from the naming, this pipe operator essentially works the same as `magrittr`'s pipe operator (at least for simple operations)

- See [this](https://www.tidyverse.org/blog/2023/04/base-vs-magrittr-pipe/) `tidyverse` blog entry for differences between both
]

.pull-right[

```r
set.seed(21903)

x &lt;- rnorm(1000, mean = 0, sd = 1)

# Basic usage
x |&gt;
  mean()
```

```
## [1] 0.007922553
```

```r
# Using the LHS placeholder `_`
TRUE |&gt;
  mean(c(x, NA), na.rm = _)
```

```
## [1] 0.007922553
```
]

---

layout: false
class: middle
background-image: url("https://purrr.tidyverse.org/logo.png")
background-size: 100px
background-position: 90% 10%

## `purrr`

&gt; `purrr` enhances R’s functional programming (FP) toolkit by providing a complete and consistent set of tools for working with functions and vectors. If you’ve never heard of FP before, the best place to start is the family of `map()` functions which allow you to replace many `for` loops with code that is both more succinct and easier to read.
&gt;
&gt; .right[&lt;a name=cite-purrr&gt;&lt;/a&gt;[Wickham and Henry (2022)](#bib-purrr)]

---

## `map()`


```r
?purrr::map
```

Similar to `apply()`, `map()` applies a function over each element of an input list or vector and returns an object of the same length.

- Takes an input `.x` (list or vector) and transforms it using a function `.f`

- Arguments to be passed on to `.f` can be defined after `.f`, separated by commas

- Contrary to `apply()`, `purrr`'s `map_*()` function are type-consistent, e. g. `map()` always returns a list

- There are several variants of `map` that return pre-specified types: `map_int()` (integer), `map_dbl()` (double), `map_chr()` (character), `map_df()` (data frame)

- `walk()` executes `.f` on `.x` but returns `.x` (useful for side-effects of `.f` such as exporting data)

---

## Example: `map_df()`

.pull-left[
- Pipe `df` into `map_df()` to standardize each column and return a data frame with standardized columns

- Anonymous functions can be defined inside `map()` functions

- Lambdas can be used if the LHS should define an argument in the RHS function that is not placed at the first position

- Lambdas behave similar to pipes in that the LHS value is called via `.`

- See `vignette("base")` for more many more handy use cases
]

.pull-right[
.panelset[
.panel[.panel-name[Named Function]

```r
df %&gt;% 
  map_df(standardize) %&gt;% 
  head(n = 5) # Print top 5 rows 
```

```
## # A tibble: 5 × 3
##        x       y      z
##    &lt;dbl&gt;   &lt;dbl&gt;  &lt;dbl&gt;
## 1 -0.903 -1.61    0.822
## 2 -1.59   0.982   1.68 
## 3  1.47   0.0548 -0.483
## 4  0.508 -0.829  -0.367
## 5 -1.51   1.39    0.833
```
]
.panel[.panel-name[Anonymous]

```r
df %&gt;% 
  map_df(function(x) {
    (x - mean(x)) / sd(x)
  }) %&gt;% 
  head(n = 5)
```

```
## # A tibble: 5 × 3
##        x       y      z
##    &lt;dbl&gt;   &lt;dbl&gt;  &lt;dbl&gt;
## 1 -0.903 -1.61    0.822
## 2 -1.59   0.982   1.68 
## 3  1.47   0.0548 -0.483
## 4  0.508 -0.829  -0.367
## 5 -1.51   1.39    0.833
```
]
.panel[.panel-name[Lambda]

```r
df %&gt;% 
  map_df(~ standardize(x = .)) %&gt;% 
  head(n = 5)
```

```
## # A tibble: 5 × 3
##        x       y      z
##    &lt;dbl&gt;   &lt;dbl&gt;  &lt;dbl&gt;
## 1 -0.903 -1.61    0.822
## 2 -1.59   0.982   1.68 
## 3  1.47   0.0548 -0.483
## 4  0.508 -0.829  -0.367
## 5 -1.51   1.39    0.833
```

]
]
]

---

layout: false
class: middle

# The `tidyverse`

---

layout: false
class: middle
background-image: url("https://tidyverse.tidyverse.org/logo.png")
background-size: 100px
background-position: 90% 10%

## `tidyverse`

&gt; The tidyverse is a set of packages that work in harmony because they share common data representations and API design. The `tidyverse` package is designed to make it easy to install and load core packages from the tidyverse in a single command.
&gt;
&gt; .right[&lt;a name=cite-tidyverse&gt;&lt;/a&gt;[Wickham, Averick, Bryan, Chang, McGowan, François, Grolemund, Hayes, Henry, Hester, Kuhn, Pedersen, Miller, Bache, Müller, Ooms, Robinson, Seidel, Spinu, Takahashi, Vaughan, Wilke, Woo, and Yutani (2019)](https://doi.org/10.21105/joss.01686)]

---

## Installation and Use

- Packages included in the `tidyverse` meta package cover a wide range of applications covering almost any task required in data analysis projects:

  - Importing
  - Tidying
  - Transforming
  - Visualizing
  - Programming
  
- Loading the `tidyverse` package automatically loads a set of core packages, commonly used for these tasks (e. g. `magrittr` and `purrr` are part of the core packages)

- Over the course of the semester, you will become familiar with the fundamental packages and concepts of the `tidyverse`


```r
# Install and load the tidyverse
install.packages("tidyverse")
library(tidyverse)
```

---

## Tidyverse Principles

- `tidyverse` packages share a common Application Programming Interface (API), making it easy to follow a consistent programming style, when using its packages

- The tidy API follows these rules:

  1. Reuse existing data structures
  
  2. Compose simple functions with the pipe
  
  3. Embrace functional programming
  
  4. Design for humans

--

- See the [tidy tools manifesto](https://tidyverse.tidyverse.org/articles/manifesto.html) for more information
  
---

## Reuse Existing Data Structures

- Existing data structures are re-used whenever possible

- Common data structures are **easier for users to get accustomed to** than than special-purpose structures

- R is mainly for statistical programming: Many packages work with rectangular data with observations as rows and variables as columns &amp;rarr; using the `base` R data structure for rectangular data

- For lower level data structures such as vectors, use `base` R's atomic vector structure

---

## Compose Simple Functions with the Pipe

- Reduce complex problems to simple tasks that can be chained

- Keep functions as simple as possible (but not too simple)

  - **Each function** should achieve **one task**
  
  - Rule of thumb: You should be able to explain the goal of your function in one sentence

- Avoid mixing side-effects and transformations: Each function should either transform an input and return the output *or* be used for their side effect

- Define function names as verbs (they *do* something)

---

## Embrace Functional Programming

- Use what R is made for: Functions!

- Focus on immutable objects and copy-on-modify semantics

- Use `apply` or `purrr`'s `map` functions instead of loops and copy-pasting code

---

## Design for Humans

- In the end, your **code must be written, read and understood by humans**

- Computer efficiency is not as important in data analysis as the main portion of your analysis is spent on thinking about *how* to solve your problem

- Follow a **consistent naming** scheme for your functions

- Use explicit and descriptive names so that you can still follow your code if you come back to it later

- Let objects of a family of objects be identified by a common prefix not suffix (helps with autocomplete when writing code)

---

class: middle

# Style Guide

---

## The Tidyverse Style Guide

- This course mostly follows the coding style proposed by &lt;a name=cite-styleguide&gt;&lt;/a&gt;[Wickham (2023)](https://style.tidyverse.org/index.html)

- Note that this style guide reflects *opinions* on how good code should look like

- Many of these style decisions, however, do make your code easier to write, read and understand

- Most importantly, your code should follow a consistent style!

- If you want to learn how to ensure following the tidyverse style guide programmatically, check out the [`styler`](https://styler.r-lib.org/) package

---

## Files

.pull-left[
#### Names

- Name your files meaningfully and in lower case
- Use `-` or `_` to separate words
- If files are run in sequential order, use numbers as prefixes (that way files are properly ordered in the explorer)

#### Organisation

- Organize files in folders
- Give concise and descriptive names to folders
- Store script where only functions are defined in a folder called "R"
- Complex functions should be stored in separate files
]
.pull-right[

```r
fence_migration
|-- data
    |-- processed
        |-- migration_data.csv
    |-- raw
        |-- enoe_survey.csv
        |-- fence_construction.csv
|-- analysis
    |-- 00_data_processing.R
    |-- 01_exploration.R
    |-- 02_transforming.R
    |-- 03_model.R
    |-- 04_results.R
|-- output
    |-- coef_plot.png
    |-- summary_table.tex
|-- R
    |-- standardize.R
|-- fence_migration.Rproj
```

]

---

## Internal File Structure

.pull-left[
- Load packages at the top of your R scripts

- Indicate sections with `#`

  - If your sections have subsections, indicate them with one more `##`
  - First level section `#`, second level section `##`, ...
  - Write `####` at the end of the line to let R know that this is a code section
  - This way, when you open the file outline (`Ctrl + Shift + O`), you can see a table of contents for your script

- Write `#` followed by underscores up until `####` before a new section to create separation lines between sections (makes the ToC more readable)
]
.pull-right[

```r
#_______________________________________####
#   Data Preparation                    ####

library(tidyverse)

#_______________________________________####
#   Import                              ####

in_path &lt;- "data/raw/"

##  Survey Data                         ####

df_survey &lt;- in_path %&gt;% 
  paste0("enoe_survey.csv") %&gt;% 
  read_csv()
```

]

---

layout: true

## Syntax

---

.pull-left[
#### Object Names

- Use **snake case** for variable and function names: Separate words within a name with an underscore (`_`)

- Variable names should be nouns and function names should be verbs

- Do not re-use names of other functions

- Give objects of the same family a common prefix

- Be descriptive with the names you choose (even if they may be longer)
]
.pull-right[

```r
x &lt;- rnorm(50, 0, 1)

standardize &lt;- function(x, na.rm = TRUE) {
  if(!is.numeric(x))
    stop("x has to be numeric")
  
  x_mean &lt;- mean(x, na.rm = na.rm)
  
  x_sd &lt;- sd(x, na.rm = na.rm)
  
  (x - x_mean) / x_sd
}

x_std &lt;- standardize(x, na.rm = TRUE)
```

]

---

.pull-left[
#### Spacing

- Always put an empty space after a comma, not before!

- Do not put spaces inside/outside parentheses of functions

- Place a space after closing parentheses

- Surround infix operators (`=`, `+`, `&lt;-`, ...) by spaces

.pull-left.short-width[
.big-emoji[⚠️]
]

.pull-right.lo-wi2[
Do not surround `::`, `:::`, `$`, `@`, `?`, `^` and the subsetting operators by spaces!
]
]
.pull-right[

```r
x &lt;- rnorm(50, 0, 1)

standardize &lt;- function(x, na.rm = TRUE) {
  if(!is.numeric(x))
    stop("x has to be numeric")
  
  x_mean &lt;- mean(x, na.rm = na.rm)
  
  x_sd &lt;- sd(x, na.rm = na.rm)
  
  (x - x_mean) / x_sd
}

x_std &lt;- standardize(x, na.rm = TRUE)
```

]

---

.pull-left[
#### Function Calls


- Provide names for **detail** arguments when you call a function

- Names for **data** arguments may be omitted when they are used frequently

- Re-use existing data and detail argument names where appropriate

- Do not use `&lt;-` inside function arguments

- Place the function body in the next line after `{` and indent its code

- Only use `return()` for early function exits
]
.pull-right[

```r
x &lt;- rnorm(50, 0, 1)

standardize &lt;- function(x, na.rm = TRUE) {
  if(!is.numeric(x))
    stop("x has to be numeric")
  
  x_mean &lt;- mean(x, na.rm = na.rm)
  
  x_sd &lt;- sd(x, na.rm = na.rm)
  
  (x - x_mean) / x_sd
}

x_std &lt;- standardize(x, na.rm = TRUE)
```

]

---

.pull-left[
#### Control Flow

- Separate `if` and its statement with a space

- Place the body in a new line after `{` and indent it (two spaces/`Tab`)

- Short control flow content may be placed in the same line (or the following without curly brackets)

- If `else` is used, it should be on the same line as the closing `}` of the `if` statement

- Very short `if`-`else` controls may be placed in the same line
]
.pull-right[

```r
if (x &gt; 0) {
  x_ln &lt;- log(x)
} else {
  message("x is 0 or smaller")
}

if (x &lt;= 0) "not positive" else "positive"
```

]

---

.pull-left[
#### Limit Long Lines

- If a code line does not fit your script width (indicated by the vertical line on the right), place function arguments in new lines

- Each argument should be in a separate line

- Omit argument names, when they are used commonly

- When omitting argument names, unnamed arguments may be place in the first line of the function even if the named arguments are in separate lines
]
.pull-right[

```r
some_long_function(x,
                   argument_1 = c(1, 2),
                   argument_2 = TRUE)

some_longer_almost_too_long_function(
  x,
  argument_1 = c(1, 2),
  argument_2 = TRUE
)
```

]

---

.pull-left[
#### Assignment

Use `&lt;-` **not** `=` to assign variables and functions!
]
.pull-right[

```r
# Do this
x &lt;- rnorm(50, 5, 10)

# Not this
x = rnorm(50, 5, 10)
```

]

--

.pull-left[
#### Character

- Start characters with `"`
- Use `'` for quotations inside strings
]
.pull-right[

```r
chr &lt;- "Experiment 'A'"
```
]

---

#### Comments

- Comments should start with `#` and single space

- Be concise and descriptive with comments

- Clean and readable code should reduce your need for writing comments

- Explain *why* you do something not *what* and *how*

---

layout: true

# References

---

&lt;a name=bib-magrittr&gt;&lt;/a&gt;[Bache, S. M. and H. Wickham](#cite-magrittr)
(2022). _magrittr: A Forward-Pipe Operator for R_.
https://magrittr.tidyverse.org, https://github.com/tidyverse/magrittr.

&lt;a name=bib-advancedr&gt;&lt;/a&gt;[Wickham, H.](#cite-advancedr) (2019).
_Advanced R_. 2nd. Chapman &amp; Hall/CRC. URL:
[http://adv-r.had.co.nz/](http://adv-r.had.co.nz/).

&lt;a name=bib-styleguide&gt;&lt;/a&gt;[Wickham, H.](#cite-styleguide) (2023). _The
tidyverse style guide_. URL:
[https://style.tidyverse.org/index.html](https://style.tidyverse.org/index.html)
(visited on Jan. 04, 2023).

&lt;a name=bib-tidyverse&gt;&lt;/a&gt;[Wickham, H., M. Averick, J. Bryan, et
al.](#cite-tidyverse) (2019). "Welcome to the tidyverse". In: _Journal
of Open Source Software_ 4.43, p. 1686. DOI:
[10.21105/joss.01686](https://doi.org/10.21105%2Fjoss.01686).

&lt;a name=bib-r4ds&gt;&lt;/a&gt;[Wickham, H. and G. Grolemund](#cite-r4ds) (2016).
_R for data science. import, tidy, transform, visualize, and model
data_. O'Reilly. URL:
[https://r4ds.had.co.nz/](https://r4ds.had.co.nz/).

&lt;a name=bib-purrr&gt;&lt;/a&gt;[Wickham, H. and L. Henry](#cite-purrr) (2022).
_purrr: Functional Programming Tools_. https://purrr.tidyverse.org/,
https://github.com/tidyverse/purrr.
    </textarea>
<style data-target="print-only">@media screen {.remark-slide-container{display:block;}.remark-slide-scaler{box-shadow:none;}}</style>
<script src="https://remarkjs.com/downloads/remark-latest.min.js"></script>
<script>var slideshow = remark.create({
"ratio": "16:9",
"highlightLines": true,
"countIncrementalSlides": false
});
if (window.HTMLWidgets) slideshow.on('afterShowSlide', function (slide) {
  window.dispatchEvent(new Event('resize'));
});
(function(d) {
  var s = d.createElement("style"), r = d.querySelector(".remark-slide-scaler");
  if (!r) return;
  s.type = "text/css"; s.innerHTML = "@page {size: " + r.style.width + " " + r.style.height +"; }";
  d.head.appendChild(s);
})(document);

(function(d) {
  var el = d.getElementsByClassName("remark-slides-area");
  if (!el) return;
  var slide, slides = slideshow.getSlides(), els = el[0].children;
  for (var i = 1; i < slides.length; i++) {
    slide = slides[i];
    if (slide.properties.continued === "true" || slide.properties.count === "false") {
      els[i - 1].className += ' has-continuation';
    }
  }
  var s = d.createElement("style");
  s.type = "text/css"; s.innerHTML = "@media print { .has-continuation { display: none; } }";
  d.head.appendChild(s);
})(document);
// delete the temporary CSS (for displaying all slides initially) when the user
// starts to view slides
(function() {
  var deleted = false;
  slideshow.on('beforeShowSlide', function(slide) {
    if (deleted) return;
    var sheets = document.styleSheets, node;
    for (var i = 0; i < sheets.length; i++) {
      node = sheets[i].ownerNode;
      if (node.dataset["target"] !== "print-only") continue;
      node.parentNode.removeChild(node);
    }
    deleted = true;
  });
})();
// add `data-at-shortcutkeys` attribute to <body> to resolve conflicts with JAWS
// screen reader (see PR #262)
(function(d) {
  let res = {};
  d.querySelectorAll('.remark-help-content table tr').forEach(tr => {
    const t = tr.querySelector('td:nth-child(2)').innerText;
    tr.querySelectorAll('td:first-child .key').forEach(key => {
      const k = key.innerText;
      if (/^[a-z]$/.test(k)) res[k] = t;  // must be a single letter (key)
    });
  });
  d.body.setAttribute('data-at-shortcutkeys', JSON.stringify(res));
})(document);
(function() {
  "use strict"
  // Replace <script> tags in slides area to make them executable
  var scripts = document.querySelectorAll(
    '.remark-slides-area .remark-slide-container script'
  );
  if (!scripts.length) return;
  for (var i = 0; i < scripts.length; i++) {
    var s = document.createElement('script');
    var code = document.createTextNode(scripts[i].textContent);
    s.appendChild(code);
    var scriptAttrs = scripts[i].attributes;
    for (var j = 0; j < scriptAttrs.length; j++) {
      s.setAttribute(scriptAttrs[j].name, scriptAttrs[j].value);
    }
    scripts[i].parentElement.replaceChild(s, scripts[i]);
  }
})();
(function() {
  var links = document.getElementsByTagName('a');
  for (var i = 0; i < links.length; i++) {
    if (/^(https?:)?\/\//.test(links[i].getAttribute('href'))) {
      links[i].target = '_blank';
    }
  }
})();
// adds .remark-code-has-line-highlighted class to <pre> parent elements
// of code chunks containing highlighted lines with class .remark-code-line-highlighted
(function(d) {
  const hlines = d.querySelectorAll('.remark-code-line-highlighted');
  const preParents = [];
  const findPreParent = function(line, p = 0) {
    if (p > 1) return null; // traverse up no further than grandparent
    const el = line.parentElement;
    return el.tagName === "PRE" ? el : findPreParent(el, ++p);
  };

  for (let line of hlines) {
    let pre = findPreParent(line);
    if (pre && !preParents.includes(pre)) preParents.push(pre);
  }
  preParents.forEach(p => p.classList.add("remark-code-has-line-highlighted"));
})(document);</script>

<script>
slideshow._releaseMath = function(el) {
  var i, text, code, codes = el.getElementsByTagName('code');
  for (i = 0; i < codes.length;) {
    code = codes[i];
    if (code.parentNode.tagName !== 'PRE' && code.childElementCount === 0) {
      text = code.textContent;
      if (/^\\\((.|\s)+\\\)$/.test(text) || /^\\\[(.|\s)+\\\]$/.test(text) ||
          /^\$\$(.|\s)+\$\$$/.test(text) ||
          /^\\begin\{([^}]+)\}(.|\s)+\\end\{[^}]+\}$/.test(text)) {
        code.outerHTML = code.innerHTML;  // remove <code></code>
        continue;
      }
    }
    i++;
  }
};
slideshow._releaseMath(document);
</script>
<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
(function () {
  var script = document.createElement('script');
  script.type = 'text/javascript';
  script.src  = 'https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML';
  if (location.protocol !== 'file:' && /^https?:/.test(script.src))
    script.src  = script.src.replace(/^https?:/, '');
  document.getElementsByTagName('head')[0].appendChild(script);
})();
</script>
  </body>
</html>
